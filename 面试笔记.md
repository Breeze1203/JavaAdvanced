#### equals和==
== 如果比较的对象是基本数据类型，则比较的是值，如果是对象，则判断对象的地址
equals 用来比较对象的内容是否相等，如果没有对equals方法进行重写，则比较的是所指向对象的值
#### 重写equals必须重写hashcode
这是一种规定，hashcode用于返回对象的hashcode值，如果两个对象相等，则hashcode值也应该相等，但hsahcode相等equals()方法返回值不一定为true，不同对象可能有相同hashcode值
#### 抽象类和接口
抽象类可以定义构造器，接口不可以，抽象类可以有抽象方法和具体方法，接口只能有抽象方法，抽象类可以包含静态方法，接口不可以，一个类只能继承一个抽象类，一个类可以实现多个接口，使用场景，抽象类：**当多个类有相似的行为时，可以考虑将这些行为抽象到一个基类中**，让子类去继承并实现具体的行为，**当有多个类需要共享相同的行为，但这些类之间没有明显的层级关系时**，可以使用接口
#### 重载和重写
重载：同一类中，方法名相同，参数不同
重写：子类父类中，方法名相同，参数相同，父类修饰符要低于子类
####  string stringbuffer stringbuilder的区别，string为什么不可变
string对象不可变，stringbuffer和stringbyilder都可变，stringbuffer是线程安全，stringbuilder线程不安全
#### 集合
map和collection是所有集合的父接口
##### list（可包含重复元素）
* arraylist:Object[]数组实现,
* vector:object[]数组实现
* linckedlist:双现链表实现
##### set (不可包含重复元素)
* hsahset:无序，唯一，基于hashmap实现
* linkedhashset:基于linkedhashmap实现
* treeset:有序，唯一，基于红黑树实现
##### map(存储的是键值对类型的数据，键值都可以为null,然而，因为键的唯一性，所以只能有一个）
* hashmap:数组加链表的形式实现
* linkedhashmap:继承自hashmap,所以底层仍然是数组加链表的形式实现
* hsahtable：数组加链表组成
* treemap:红黑树
##### arraylist操作元素时间复杂度
* 头部删除或添加元素，后面的元素都的向前移动，是O(N)复杂度
* 尾部添加或删除都是O(1)
* 指定位置删除，需要将目标元素后的元素向前移动，也是O(N）复杂度
##### linkedlist操作元素时间复杂度
* 头部和尾部删除或添加元素都是O(1)复杂度
* 指定位置插入或删除，要需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)
##### arraylist和linkedlist区别
* 底层实现不同考虑
* 都是线程不安全的
* arraylist支持快速访(实现randomAccess接口)，linkedlist不支持
* 操作元素时间复杂的考虑
