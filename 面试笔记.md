#### jvm内存区域
* 程序计数器：（私有，当前线程所指向字节码的指示器）
* 虚拟机栈：是java方法执行的内存模型，栈帧：局部变量表，操作站，动态链接，方法出口等信息
* 本地方法栈：跟虚拟机栈类似，只不过是本地方法
* 堆：对象和数组（分为新生代和老年代）
* 方法区：又叫永久代，存储被jvm加载类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据
#### gc垃圾回收算法
* 标记清楚
* 复制
* 标记整理
* 分带收集
#### 四种引用类型
* 强引用：把一个对象赋给一个引用变量
* 软应用
* 弱引用
* 虚引用：主要作用是耿总对象被垃圾回收的状态
#### 类加载的几个阶段
* 加载（Loading）：该阶段是类加载过程的第一个阶段。在加载阶段，Java 虚拟机通过类加载器查找并读取类的字节码数据，并将其转换为运行时数据结构，如方法区中的 Class 对象。类加载器负责从文件系统、网络或其他来源加载类的字节码数据，并创建 Class 对象。
* 验证（Verification）：在验证阶段，虚拟机将对类的字节码进行验证，以确保其符合 Java 虚拟机规范。这些验证步骤包括对字节码的结构、语义、符号引用等方面的检查，以防止安全和运行时错误。
* 准备（Preparation）：在准备阶段，虚拟机为类的静态变量（被 static 修饰的字段）分配内存，并进行默认初始化。静态变量会被赋予默认值，如引用类型为 null，数值类型为零或者 false。
* 解析（Resolution）：在解析阶段，虚拟机将符号引用转换为直接引用。符号引用是一种在编译时使用的地址或者方法的标识，而直接引用则是指向真正要调用的目标的指针、句柄或者偏移量。通过解析，虚拟机可以确定调用的方法、字段的具体位置及最终的内存布局。
* 初始化（Initialization）：初始化阶段是类加载过程的最后一个阶段。在该阶段，虚拟机会执行类的初始化代码，为静态变量赋予指定的初始值，并执行静态代码块（static 块）中的逻辑。类的初始化过程由虚拟机保证，多个线程同时初始化同一类时会进行同步处理。
#### equals和==
== 如果比较的对象是基本数据类型，则比较的是值，如果是对象，则判断对象的地址
equals 用来比较对象的内容是否相等，如果没有对equals方法进行重写，则比较的是所指向对象的值
#### 重写equals必须重写hashcode
这是一种规定，hashcode用于返回对象的hashcode值，如果两个对象相等，则hashcode值也应该相等，但hsahcode相等equals()方法返回值不一定为true，不同对象可能有相同hashcode值
#### 抽象类和接口
抽象类可以定义构造器，接口不可以，抽象类可以有抽象方法和具体方法，接口只能有抽象方法，抽象类可以包含静态方法，接口不可以，一个类只能继承一个抽象类，一个类可以实现多个接口，使用场景，抽象类：**当多个类有相似的行为时，可以考虑将这些行为抽象到一个基类中**，让子类去继承并实现具体的行为，**当有多个类需要共享相同的行为，但这些类之间没有明显的层级关系时**，可以使用接口
#### 重载和重写
重载：同一类中，方法名相同，参数不同
重写：子类父类中，方法名相同，参数相同，父类修饰符要低于子类
####  string stringbuffer stringbuilder的区别，string为什么不可变
string对象不可变，stringbuffer和stringbyilder都可变(底层是数组的扩容)，stringbuffer是线程安全，stringbuilder线程不安全
#### 集合
map和collection是所有集合的父接口
##### list（可包含重复元素）
* arraylist:Object[]数组实现,
* vector:object[]数组实现
* linckedlist:双现链表实现
##### set (不可包含重复元素)
* hsahset:无序，唯一，基于hashmap实现
* linkedhashset:基于linkedhashmap实现
* treeset:有序，唯一，基于红黑树实现
##### map(存储的是键值对类型的数据，键值都可以为null,然而，因为键的唯一性，所以只能有一个）
* hashmap:数组加链表的形式实现
* linkedhashmap:继承自hashmap,所以底层仍然是数组加链表的形式实现
* hsahtable：数组加链表组成
* treemap:红黑树
##### arraylist操作元素时间复杂度
* 头部删除或添加元素，后面的元素都的向前移动，是O(N)复杂度
* 尾部添加或删除都是O(1)
* 指定位置删除，需要将目标元素后的元素向前移动，也是O(N）复杂度
##### linkedlist操作元素时间复杂度
* 头部和尾部删除或添加元素都是O(1)复杂度
* 指定位置插入或删除，要需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)
##### arraylist和linkedlist区别
* 底层实现不同考虑
* 都是线程不安全的
* arraylist支持快速访(实现randomAccess接口)，linkedlist不支持
* 操作元素时间复杂的考虑
#### 多线程
* 继承Thread
* 实现Runnable等
##### 线程生命周期
* 新建状态
* 就绪状态
* 运行状态
* 阻塞状态
* 死亡销毁
#### spring（综合性、轻量级、依赖注入、面向切面编程、数据访问支持和容器管理）
spring是一个ioc和aop的容器框架，ioc：依赖注入，控制反转 aop：面向切面编程，容器包含并管理应用对象的生命周期
#### 创建bean对象的方式
* 构造器
* 工厂（静态工厂，实例工厂)
* 注解
#### springbean的生命周期
* 实例化
* 属性赋值 （构造参数注入，setter注入等）
* 初始化 （检查aware接口，前置处理，后置处理等，这个过程中可能自定义了一些初始化之前的操作和之后的操作）
* 使用
* 销毁 （销毁前可能自己配置了一些销毁之前的方法)

